/**
 * Handle manual slide navigation for ImageCarousel
 * generated by ChatGPT and customized by @vandangnhathung
 *
 * @param {"left" | "right"} dir - Direction of slide animation.
 * @param {Object} refs - A collection of GSAP and DOM references.
 * @param {React.MutableRefObject<number>} refs.slideItemWidthRef - Width of one slide item.
 * @param {React.MutableRefObject<number>} refs.containerWidthRef - Container width.
 * @param {React.MutableRefObject<number>} refs.totalWidthRef - Total width of all slides.
 * @param {React.MutableRefObject<number>} refs.totalRef - Current X offset.
 * @param {React.MutableRefObject<boolean>} refs.infiniteRef - Whether carousel is infinite.
 * @param {React.MutableRefObject<gsap.core.Tween | null>} refs.manualTweenRef - Reference to current tween.
 * @param {React.MutableRefObject<((v: number) => void) | null>} refs.xToRef - Wrapped GSAP quickTo handler.
 * @param {React.MutableRefObject<((v: number) => void) | null>} refs.noWrapXToRef - Non-wrapped GSAP quickTo handler.
 * @param {Function} setIsLeftDisabled - React setState to disable left button.
 * @param {Function} setIsRightDisabled - React setState to disable right button.
 * @returns {void}
 */

import gsap from "gsap"
import { checkBoundaries } from "./checkBoundaries"

const MANUAL_SLIDE_DURATION = 0.6

export function handleManualSlide(
  dir: "left" | "right",
  refs: {
    slideItemWidthRef: React.MutableRefObject<number>
    containerWidthRef: React.MutableRefObject<number>
    totalWidthRef: React.MutableRefObject<number>
    totalRef: React.MutableRefObject<number>
    infiniteRef: React.MutableRefObject<boolean>
    manualTweenRef: React.MutableRefObject<gsap.core.Tween | null>
    xToRef: React.MutableRefObject<((v: number) => void) | null>
    noWrapXToRef: React.MutableRefObject<((v: number) => void) | null>
  },
  setIsLeftDisabled: React.Dispatch<React.SetStateAction<boolean>>,
  setIsRightDisabled: React.Dispatch<React.SetStateAction<boolean>>
): void {
  const {
    slideItemWidthRef,
    containerWidthRef,
    totalWidthRef,
    totalRef,
    infiniteRef,
    manualTweenRef,
    xToRef,
    noWrapXToRef,
  } = refs

  // === Calculate new position ===
  const slideItemWidth = slideItemWidthRef.current || 300
  const delta = dir === "left" ? slideItemWidth : -slideItemWidth
  let end = totalRef.current + delta

  // === Boundary constraints (non-infinite mode) ===
  if (!infiniteRef.current) {
    const maxScroll = -(totalWidthRef.current - containerWidthRef.current)
    end = Math.max(maxScroll, Math.min(0, end))
    if (Math.abs(end - totalRef.current) < 1) return // small movement ignored
  }

  // === Kill any active tween before starting a new one ===
  manualTweenRef.current?.kill()
  const useXTo = infiniteRef.current ? xToRef.current : noWrapXToRef.current

  // === Animate manual slide ===
  manualTweenRef.current = gsap.to(
    { v: totalRef.current },
    {
      v: end,
      duration: MANUAL_SLIDE_DURATION,
      ease: "power2.out",
      onUpdate: function () {
        totalRef.current = (this.targets() as any)[0].v
        useXTo?.(totalRef.current)
        checkBoundaries(totalRef, totalWidthRef, containerWidthRef, infiniteRef, setIsLeftDisabled, setIsRightDisabled)
      },
      onComplete: () => {
        totalRef.current = end
        manualTweenRef.current = null
        checkBoundaries(totalRef, totalWidthRef, containerWidthRef, infiniteRef, setIsLeftDisabled, setIsRightDisabled)
      },
    }
  )
}
